# GC常见问题

## 1 什么时候对象会进入老年代？
1. 对象年龄超过-XX:MaxTenuringThreshold设置的阈值，默认是15，每熬过一次GC，对象年龄加1。
2. 超过survivor区的50%的对象，可以直接进入老年代，不一定非得要15岁。
3. 内存占用超过-XX:PretenureSizeThreshold参数的大对象，直接进入老年代，这样有助于避免浪费young区空间。

## 2 JVM内存结构或内存模型
JVM虚拟机：
	* 线程隔离区
		* 虚拟机栈
		* 本地方法栈
		* 程序计数器
	* 共享数据区
		* 无数据空间(方法区)
		* 堆
### 2.1 虚拟机栈
1. 也叫线程栈，是线程私有的，栈中分配的是基本类型和自定义对象的引用。
2. 每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。
3. 栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。

4. 栈是存放线程调用方法时存储局部变量表，操作，方法出口等与方法执行相关的信息，栈大小由Xss来调节，方法调用层次太多会撑爆这个区域。
5. 栈溢出一般只会出现无限循环的递归中，另外，线程太多也会占满栈区域。
6. 一个完整的栈帧包含：局部变量表（基本数据类型变量），操作数栈，动态连接信息，方法完成和异常完成信息。
7. 局部变量表概念和特征：由若干个Slot组成，长度由编译期决定。
单个Slot可以存储一个类型为boolean ,byte,char, short, float, reference和returnAddress的数据，两个Slot可以存储一个类型为long或double的数据。
8. 局部变量表用于方法间参数传递，以及方法执行过程中存储基础数据类型的值和对象的引用。
### 2.2 本地方法栈
1. 线程私有
2. 后进先出栈
3. 作用是支撑Native方法的调用，执行和退出
### 2.3 程序计数器
1. 程序计数器是一个记录着当前线程所执行的字节码的行号指示器。
2. JVM的多线程是通过CPU时间片轮转算法来实现的。
3. 也就是说，某个线程在执行过程中可能会因为时间片耗尽而被挂起，而另一个线程获取到时间片开始执行。
4. 简单的说程序计数器的主要功能就是记录着当前线程所执行的字节码的行号指示器。

### 2.4 方法区
方法区存储了类的元数据信息、静态变量、常量等数据。
### 2.5 heap堆
大部分都是用分代回收算法，堆被划分为，新生代，老年代，新生代有eden区和两个survivor区。
### 2.6 小结
1. JVM内存模型划分为线程私有区域和共享区域
2. 虚拟机栈/本地方法栈负责存放线程执行方法栈帧
3. 程序计数器用于记录线程执行指令的位置
4. 方法区（元数据区）存储类的元数据信息、静态变量、常量等数据
5. 堆（heap)使用new关键字创建的对象都会进入堆中，堆被划分为新生代和老年代。

## 3 什么时候对象可以被收回
1.引用记数：JVM为每个对象维护一个引用计数，假设A对象引用计数为零说明没有任务对象引用A对象，那A对象就可以被回收了，但是引用计数有个缺点就是无法解决循环引用的问题。
2. GC Roots，通过一系列的名为GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明对象是不可用的。
3. 在Java中，可以作为GC Roots的对象包括下面几种：
* 虚拟机栈中引用的对象
* 方法区中类静态属性引用的对象
* 方法区中的常量引用的对象
* 本地方法栈中JNI（即一般说的Native方法）的引用的对象

## 4 常见的垃圾回收算法
1. 标记清除
	先标记，再清除，从GC Root扫描，标记对象为存活状态，清除掉没被标记的对象。
	缺点是有内存碎片。
2. 标记整理
	先做一遍标记清除，然后再整理一遍内存。没有内存碎片，但是慢的一逼。
3. 复制算法
	浪费一半空间，使用其中一部分空间来分配对象，满了之后将存活的对象移动到另一块空白区域，清除之前那半。交替使用。会浪费一半空间
## 5. 什么是空间分配担保策略
1. JVM在发生Minor GC之前，检查老年代最大连续可用空间是否大于新生代所有对象的总空间，如果大于，说明Minor GC是安全的。
2. 如果小于，查看HandlePromotionFailure的值是否是ture，如果是，检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小，如果大于尝试一次Minor GC。
3. 如果HandlePromotionFailure=false，改为进行一次full GC。

## 6. 优化减少Full GC
1. 估算系统每秒占用内存数量
2. 计算Minor GC的间隔
3. 检查Survivor区大小
4. 针对业务场景，尽量避免对象进入老年代，可以适当调大young区
5. 判断当前服务是否可能有大对象，如果有，调整PretenureSizeThreshold参数
6. 合理设置对象年龄
