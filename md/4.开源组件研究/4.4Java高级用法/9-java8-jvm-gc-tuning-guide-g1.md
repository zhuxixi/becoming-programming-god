# 9 Garbage-First Garbage Collector G1收集器

G1收集器是一个服务端程序的收集器，目标是带有巨量内存的多处理器机器。它尝试在满足高吞吐量的情况也能够满足停顿时间。所有的heap 操作，例如全局mark，都是与应用线程并发执行的。这可以防止与heap或存活对象成比例的中断。

G1收集器通过几项技术来达到上述目标。

堆被分割成一组大小相等的regions，每个region是一个连续的虚拟内存范围。G1执行一个并发的全局标记阶段来确定整个堆中对象的活性。标记阶段完成后，G1知道哪些rigion大部分是空的。它首先收集这些区域，这通常会产生大量的空闲空间。这就是为什么这种垃圾收集方法称为Garbage First。顾名思义，G1将收集和压缩活动集中在堆中可能充满可回收对象(即垃圾)的区域。G1使用暂停预测模型来满足用户定义的暂停时间目标，并根据指定的暂停时间目标选择要收集的region数。

G1将对象从堆的一个或多个region复制到堆上的另一个region，并在此过程中压缩和释放内存。这种转移是在多处理器上并行执行的，以减少暂停时间并增加吞吐量。因此，每次垃圾收集时，G1都在不断地减少碎片。这一点比前面介绍的回收器要牛逼。CMS不做压缩。Parallel只执行全堆压缩，这会导致相当长的停顿时间。

需要注意的是G1不是一个实时收集器。G1收集器能够大概率满足停顿时间的要求，但也不全是绝对的。根据之前收集的数据，G1可以提前预估在目标时间内可以收集多少个区域。因此，收集器对收集区域的成本有一个合理准确的模型，它使用这个模型来决定满足停顿时间的需求要收集哪些region和多少region。

G1的首要关注点是为用户提供一个可以在大堆的环境下保证理想GC停顿时间。这里说的堆大小约为6gb或更大，并且停顿时间低于0.5秒。

目前使用CMS或者parallel收集器的应用程序，如果你的场景满足以下几点，推荐换成G1收集器：
* Java堆有超过50%的活跃对象
* 分配对象的频率和对象升代的频率很高
* 应用程序正在经历不必要的超长停顿(停顿时间大于0.5或1秒)

G1是计划用来替代CMS的。将G1与CMS进行比较，可以发现G1要比CMS更好一些。一个不同之处在于G1是一个压缩收集器。此外，G1比CMS收集器提供了更多可预测的垃圾收集暂停，并允许用户指定预期的停顿时间。

与CMS一样，G1是为需要更短GC停顿的应用程序设计的。

如下图所示，G1将heap切分成定长的region：
![9-heap-division-by-g1](9-heap-division-by-g1.png)

从逻辑上说，G1也是分代的。一组空白区域被指定为logical young generation(逻辑young区)。在图中，young区是浅蓝色的。分配是在logical young generation之外完成的，当young区满时，将对该区域集进行垃圾收集(minor gc)。在某些情况下，可以同时对young区(深蓝色的旧区域)之外的区域进行垃圾收集。这称为mixed收集。在图中，正在收集的区域用红色方框标记。该图表示当前在做mixed收集，因为同时收集了young区和tenured区。垃圾收集是一个压缩的收集，它将活动对象复制到选定的、最初为空的区域。根据幸存对象的年龄，可以将对象复制到survivor区域(用“S”标记)或复制到tenred(没显示标注出来)。标有“H”的区域内，包含了体积超过半个区域的巨型对象，并经过特殊处理;具体看Humongous Objects and Humongous Allocations in Garbage-First Garbage Collector。

## Allocation (Evacuation) Failure 分配失败

与CMS一样，当应用程序运行时，G1收集器执行部分收集，可能会出现应用程序分配对象的速度比垃圾收集器恢复空间快。在G1中，当G1将活动数据从一个区域复制到另一个区域时发生故障(耗尽Java堆)。复制是为了压缩活动数据。如果在垃圾回收区域的回收过程中找不到空闲(空)区域，则会发生分配失败(因为没有空间来分配)，此时会触发一次STW的停顿。

## Floating Garbage 漂浮垃圾

对象可能在G1收集期间死亡而不能被收集。G1使用了一种叫做“快照-开始”(SATB)的技术来保证垃圾收集器能够找到所有活动对象。SATB声明，在并发标记(整个堆上的标记)开始时处于活动状态的任何对象都被认为是集合活动状态的对象。这些漂浮垃圾下次GC就会被清理，和CMS相似。

## Pauses 停顿

G1暂停应用程序，将活动对象复制到新区域。这些停顿可以是只收集年轻区域的young gc停顿，也可以是young区和tenured区的混合收集停顿。与CMS一样，当应用程序停止时，会有一个final mark 或 remark 停顿来完成标记阶段。CMS有initial mark pause，G1将initial mark pause作为evacuation pause的一部分。G1在收集末尾会有一个清理阶段，部分是STW，部分是并发的。G1在清理阶段的STW部分去识别空的region和tenured区域的region，为下一次收集做准备。

## Card Tables and Concurrent Phases 卡牌表和并发阶段

如果垃圾收集器没有收集整个堆(增量收集)，那么可能会存在一些指针从未收集区域指向正在被收集的区域，就好比在做young gc时，young的一些对象被tenured区的对象引用，垃圾回收器必须要知道这些指针在哪里。这通常适用于分代垃圾收集器，其中堆中未收集的部分通常是tenured区，而堆中收集的部分是young区。用于保存这些信息的数据结构(tenured的指针指向young的对象)被称为remenmbered set。JVM使用一个字节数组来表示一个Card Table。每个字节对应一个Card。一个Card对应于堆中的一段地址范围。弄脏卡意味着将字节的值改为脏值;脏值可能包含一个从tenured区到young区对象的指针。

Processing a card代表查看这个card是否包含tenured区到young区的指针，如果有的话，会做一些处理，例如将这个数据结构转换成其他的数据结构。

G1包含一个并发标记阶段，会标记应用中所有已发现的活跃对象。并发标记从疏散暂停结束(初始标记工作在此完成)延伸到remark阶段。并发清理阶段将集合清空的区域添加到空闲区域列表中，并在remember set中清除这些区域。此外，并发细化线程根据需要运行，以处理被应用程序写操作弄脏的、可能具有跨区域引用的card table entry。

## Starting a Concurrent Collection Cycle 启动一次并发收集循环

如前所述，young和old区域都是试用混合收集的垃圾收集。为了收集tenured区，G1对堆中的活动对象进行全部标记。这种标记由并发标记阶段完成。当整个Java堆的占用达到参数initiatingheap佔有人百分比的值时，将启动并发标记阶段。使用命令行选项-XX设置此参数的值:initiatingheap占用百分比=<NN>。initiatingheap佔有率的默认值是45。