# Core Java Volume I - Fundamentals Content

## 第1章 Java程序设计概述
### 1.1 Java程序设计平台
### 1.2 Java白皮书的关键术语
#### 1.2.1 简单性
#### 1.2.2 面向对象
#### 1.2.3 分布式
#### 1.2.4 健壮性
#### 1.2.5 安全性
#### 1.2.6 体系结构中立
#### 1.2.7 可移植性
#### 1.2.8 解释型
#### 1.2.9 高性能
#### 1.2.10 多线程
#### 1.2.11 动态性
### 1.3 Java applet与internet
### 1.4 Java发展简史
### 1.5 关于Java常见误解

## 第2章 Java程序设计环境
### 2.1 安装Java开发工具包
#### 2.1.1 下载JDK
#### 2.1.2 设置JDK
#### 2.1.3 安装库源文件和文档
### 2.2 使用命令行工具
### 2.3 使用集成开发环境
### 2.4 运行图形化应用程序
### 2.5 构建并运行applet

## 第3章 Java的基本程序设计结构
### 3.1 一个简单的Java应用程序
### 3.2 注释
### 3.3 数据类型
#### 3.3.1 整型
#### 3.3.2 浮点类型
#### 3.3.3 char类型
#### 3.3.4 Unicode和char类型
#### 3.3.5 boolean类型
### 3.4 变量
#### 3.4.1 变量初始化
#### 3.4.2 常量 
### 3.5 运算符
#### 3.5.1 数学函数与常量
#### 3.5.2 数值类型之间的转换
#### 3.5.3 强制类型转换
#### 3.5.4 结合赋值和运算符
#### 3.5.5 自增与自减运算符
#### 3.5.6 关系和boolean运算符
#### 3.5.7 位运算符
#### 3.5.8 括号与运算符级别
#### 3.5.9 枚举类型
### 3.6 字符串
#### 3.6.1 子串
#### 3.6.2 拼接
#### 3.6.3 不可变字符串
#### 3.6.4 检测字符串是否相等
#### 3.6.5 空串与null串
#### 3.6.6 码点与代码单元
#### 3.6.7 String API
#### 3.6.8 阅读联机API文档
#### 3.6.9 构建字符串
### 3.7 输入输出
#### 3.7.1 读取输入
#### 3.7.2 格式化输出
#### 3.7.3 文件输入与输出
### 3.8 控制流程
#### 3.8.1 块作用域
#### 3.8.2 条件语句
#### 3.8.3 循环
#### 3.8.4 确定循环
#### 3.8.5 多重选择switch语句
#### 3.8.6 终端控制流程语句
### 3.9 大数值
### 3.10 数组
#### 3.10.1 for each循环
#### 3.10.2 数组初始化以及匿名数组
#### 3.10.3 数组拷贝
#### 3.10.4 命令行参数
#### 3.10.5 数组排序
#### 3.10.6 多维数组
#### 3.10.7 不规则数组

## 第4章 对象与类
### 4.1 面向对象程序设计概述
#### 4.1.1 类
#### 4.1.2 对象
#### 4.1.3 识别类
#### 4.1.4 类之间的关系
### 4.2 使用预定义类
#### 4.2.1 对象与对象变量
#### 4.2.2 JAva类库中的LocalDate类
#### 4.2.3 更改器方法与访问器方法
### 4.3 用户自定义类
#### 4.3.1 Employee类
#### 4.3.2 多个源文件的使用
#### 4.3.3 剖析Employee类
#### 4.3.4 从构造器开始
#### 4.3.5 隐式参数与显示参数
#### 4.3.6 封装的优点
#### 4.3.7 基于类的访问权限
#### 4.3.8 私有方法
#### 4.3.9 final实例域
### 4.4 静态域与静态方法
#### 4.4.1 静态域
#### 4.4.2 静态常量
#### 4.4.3 静态方法
#### 4.4.4 工厂方法
#### 4.4.5 main方法
### 4.5 方法参数
### 4.6 对象构造
#### 4.6.1 重载
#### 4.6.2 默认域初始化
#### 4.6.3 无参数的构造器
#### 4.6.4 显式域的初始化
#### 4.6.5 参数名
#### 4.6.6 调用另一个构造器
#### 4.6.7 初始化块
#### 4.6.8 对象析构与finalize方法
### 4.7 包
#### 4.7.1 类的导入
#### 4.7.2 静态导入
#### 4.7.3 将类放入包中
#### 4.7.4 包作用域
### 4.8 类路径
#### 4.8.1 设置类路径
### 4.9 文档注释
#### 4.9.1 注释的插入
#### 4.9.2 类注释
#### 4.9.3 方法注释
#### 4.9.4 域注释
#### 4.9.5 通用注释
#### 4.9.6 包与概述注释
#### 4.9.7 注释的抽取
### 4.10 类设计技巧

## 第5章 继承
### 5.1 类、超类和子类
#### 5.1.1 定义子类
#### 5.1.2 覆盖方法
#### 5.1.3 子类构造器
#### 5.1.4 继承层次
#### 5.1.5 多态
#### 5.1.6 理解方法调用
#### 5.1.7 阻止继承final类和方法
#### 5.1.8 强制类型转换
#### 5.1.9 抽象类
#### 5.1.10 受保护访问
### 5.2 Object：所有类的超类
#### 5.2.1 equals方法
#### 5.2.2 相等测试与继承
#### 5.2.3 hashCode方法
#### 5.2.4 toString方法
### 5.3 泛型数组列表
#### 5.3.1 访问数组列表元素
#### 5.3.2 类型化与原始数组列表的兼容性
### 5.4 对象包装器与自动装箱
### 5.5 参数数量可变的方法
### 5.6 枚举类
### 5.7 反射
#### 5.7.1 Class类
#### 5.7.2 捕获异常
#### 5.7.3 利用反射分析类的能力
#### 5.7.4 在运行时使用反射分析对象
#### 5.7.5 使用反射编写泛型数组代码
#### 5.7.6 调用任意方法
### 5.8 继承的设计技巧

## 第6章 接口、lambda表达式与内部类
### 6.1 接口
#### 6.1.1 接口概念
#### 6.1.2 接口的特性
#### 6.1.3 接口与抽象类
#### 6.1.4 静态方法
#### 6.1.5 默认方法
#### 6.1.6 解决默认方法冲突
### 6.2 接口实例
#### 6.2.1 接口与回调
#### 6.2.2 Comparator接口
#### 6.2.3 对象克隆
### 6.3 lambda表达式
#### 6.3.1 为什么引入lambda表达式
#### 6.3.2 lambda表达式的语法
#### 6.3.3 函数式接口
#### 6.3.4 方法引用
#### 6.3.5 构造器引用
#### 6.3.6 变量作用域
#### 6.3.7 处理lambda表达式 
#### 6.3.8 再谈Comparator
### 6.4 内部类
#### 6.4.1 使用内部类访问对象状态
#### 6.4.2 内部的特殊语法规则
#### 6.4.3 内部类是否有用、必要和安全
#### 6.4.4 局部内部类
#### 6.4.5 由外部方法访问变量
#### 6.4.6 匿名内部类
#### 6.4.7 静态内部类
### 6.5 代理
#### 6.5.1 何时使用代理
#### 6.5.2 创建代理对象
#### 6.5.3 代理类的特性

## 第7章 异常、断言和日志
### 7.1 处理错误
#### 7.1.1 异常分类
#### 7.1.2 声明受查异常
#### 7.1.3 如何抛出异常
#### 7.1.4 创建异常类
### 7.2 捕获异常
#### 7.2.1 捕获异常
#### 7.2.2 捕获多个异常
#### 7.2.3 再次抛出异常与异常链
#### 7.2.4 finally子句
#### 7.2.5 带资源的try语句
#### 7.2.6 分析堆栈轨迹元素
### 7.3 使用异常机制的技巧
### 7.4 使用断言
#### 7.4.1 断言的概念
#### 7.4.2 启用和禁用断言
#### 7.4.3 使用断言完成参数检查
#### 7.4.4 为文档假设使用断言
### 7.5 记录日志
#### 7.5.1 基本日志
#### 7.5.2 高级日志
#### 7.5.3 修改日志管理器配置
#### 7.5.4 本地化
#### 7.5.5 处理器
#### 7.5.6 过滤器
#### 7.5.7 格式化器
#### 7.5.8 日志记录说明
### 7.6 调试技巧
## 第8章 泛型程序设计
### 8.1 为什么要使用泛型程序设计
#### 8.1.1 类型参数的好处
#### 8.1.2 谁想成为泛型程序员
### 8.2 定义简单泛型类
### 8.3 泛型方法
### 8.4 类型变量的限定
### 8.5 泛型代码和虚拟机
#### 8.5.1 类型擦除
#### 8.5.2 翻译泛型表达式
#### 8.5.3 翻译泛型方法
#### 8.5.4 调用遗留代码
### 8.6 约束与局限性
#### 8.6.1 不能用基本类型实例化类型参数
#### 8.6.2 运行时类型查询只适用于原始类型
#### 8.6.3 不能创建参数化类型的数组
#### 8.6.4 Varags警告
#### 8.6.5 不能实例化类型变量
#### 8.6.6 不能构造泛型数组
#### 8.6.7 泛型类的静态上下文中类型变量无效
#### 8.6.8 不能抛出或捕获泛型类的实例
#### 8.6.9 可以消除对受查异常的检查
#### 8.6.10 注意擦除后的冲突
### 8.7 泛型类型的继承规则
### 8.8 通配符类型
#### 8.8.1 通配符概念
#### 8.8.2 通配符的超类型限定
#### 8.8.3 无限定通配符
#### 8.8.4 通配符捕获
### 8.9 反射和泛型
#### 8.9.1 泛型Class类
#### 8.9.2 使用Class参数进行类型匹配
#### 8.9.3 虚拟机中的泛型类型信息

## 第9章 集合
### 9.1 Java集合框架
#### 9.1.1 将集合的接口与实现分离
#### 9.1.2 Collection接口
#### 9.1.3 迭代器
#### 9.1.4 泛型实用方法
#### 9.1.5 集合框架中的接口
### 9.2 具体的集合
#### 9.2.1 链表
#### 9.2.2 数组列表
#### 9.2.3 散列表
#### 9.2.4 树集
#### 9.2.5 队列与双端队列
#### 9.2.6 优先级队列
### 9.3 映射
#### 9.3.1 基本映射操作
#### 9.3.2 更新映射项
#### 9.3.3 映射视图
#### 9.3.4 弱散列映射
#### 9.3.5 链接散列集与映射
#### 9.3.6 枚举集与映射
#### 9.3.7 标志散列映射
### 9.4 视图与包装器
#### 9.4.1 轻量级集合包装器
#### 9.4.2 子范围
#### 9.4.3 不可修改的视图
#### 9.4.4 同步视图
#### 9.4.5 受查视图
#### 9.4.6 关于可选操作的说明
### 9.5 算法
#### 9.5.1 排序与混排
#### 9.5.2 二分查找
#### 9.5.3 简单算法
#### 9.5.4 批操作
#### 9.5.5 集合与数组的转换
#### 9.56 编写自己的算法
